 Problem -1 : Chain of Responsibility (Bank Withdrawal)

public abstract class Approver {
    protected Approver nextApprover;
    public void setNext(Approver nextApprover){
        this.nextApprover = nextApprover;
    }
    public abstract void approve(double amount);
}
public class Cashier extends Approver {
    public void approve(double amount){
        if(amount < 10000){
            System.out.println("Approver by Cashier.");
        }else{
            nextApprover.approve(amount);
        }
    }
}
public class SeniorOfficer extends Approver {
    public void approve(double amount){
        if(amount >= 10000 && amount <= 1000000){
            System.out.println("Approved by cashier and senior officer.");
        }else{
            nextApprover.approve(amount);
        }
    }
}
public class Manager extends Approver {
    public void approve(double amount){
        if(amount > 1000000){
            System.out.println("Approved by senior officer and manager.");
        }
    }
}
public class ChainDemo {
    public static void main(String[] args) {
        Approver cashier = new Cashier();
        Approver senior = new SeniorOfficer();
        Approver manager = new Manager();

        cashier.setNext(senior);
        senior.setNext(manager);

        cashier.approve(5000);
        cashier.approve(200000);
        cashier.approve(10000000);
    }
}
Problem -2 :  Meal Ordering System -Design Pattern: Builder Pattern
public interface Item {
    public String name();
   public Packing packing();
    public float price();
}
public interface Packing {
    public String pack();
}
public class Wrapper implements Packing {
    public String pack() {
        return "Wrapper";
    }
}
public class Bottle implements Packing {
    public String pack() {
        return "Bottle";
    }
}
public abstract class Burger implements Item {

    public Packing packing(){
        return new Wrapper();
    }
    public abstract float price();
}
public abstract class ColdDrink implements Item {

    public Packing packing(){
        return new Bottle();
    }
    public abstract float price();
}
public class VegBurger extends Burger {
    public String name() {
        return "Veg Burger";
    }
    public float price() {
        return 50.0f;
    }
}
public class ChickenBurger extends Burger {
    public String name() {
        return "Chicken Burger";
    }

    public float price() {
        return 90.0f;
    }
}
public class Coke extends ColdDrink {
    public String name() {
        return "Coke";
    }
    public float price() {
        return 30.0f;
    }
}
public class Pepsi extends ColdDrink {
    public String name() {
        return "Pepsi";
    }
    public float price() {
        return 35.0f;
    }
}
import java.util.ArrayList;
import java.util.List;

public class Meal {
    private List<Item> items = new ArrayList<Item>();
    public void addItem(Item item) {
        items.add(item);
    }
    public float getCost() {
        float cost = 0.0f;
        for (Item item : items) {
            cost += item.price();
        }
        return cost;
    }
    public void showItems() {
        for (Item item : items) {
            System.out.println(
                "Item : " + item.name() +
                ", Packing : " + item.packing().pack() +
                ", Price : " + item.price()
            );
        }
    }
}
public class MealBuilder {
    public Meal prepareVegMeal() {
        Meal meal = new Meal();
        meal.addItem(new VegBurger());
        meal.addItem(new Coke());
        return meal;
    }
    public Meal prepareNonVegMeal() {
        Meal meal = new Meal();
        meal.addItem(new ChickenBurger());
        meal.addItem(new Pepsi());
        return meal;
    }
}
public class BuilderPatternDemo {
    public static void main(String[] args) {
        MealBuilder mealBuilder = new MealBuilder();
        Meal vegMeal = mealBuilder.prepareVegMeal();
        System.out.println("VEGETARIAN MEAL");
        vegMeal.showItems();
        System.out.println("Total Cost: " + vegMeal.getCost());
        System.out.println();
        Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
        System.out.println("NON-VEGETARIAN MEAL");
        nonVegMeal.showItems();
        System.out.println("Total Cost: " + nonVegMeal.getCost());
    }
}
Problem -3 : Factory Pattern
public interface Shape {
    double getArea();
}
public class Circle implements Shape {
    private double radius;
    public Circle() {
        radius = 1.0; // default value
    }
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}
public class Rectangle implements Shape {
    private double width;
    private double height;
    public Rectangle() {
        width = 2.0;
        height = 1.5; // default values
    }
    @Override
    public double getArea() {
        return width * height;
    }
}
public class Triangle implements Shape {
    private double a, b, c;
    public Triangle() {
        a = 3.0;
        b = 4.0;
        c = 5.0; // default sides
    }
    @Override
    public double getArea() {
        double s = (a + b + c) / 2;
        return Math.sqrt(s * (s - a) * (s - b) * (s - c));
    }
}
public class ShapeFactory {
    public Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } 
        else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } 
        else if (shapeType.equalsIgnoreCase("TRIANGLE")) {
            return new Triangle();
        }

        return null;
    }
}
public class FactoryPatternDemo {
    public static void main(String[] args) {
        ShapeFactory shapeFactory = new ShapeFactory();

        Shape circle = shapeFactory.getShape("CIRCLE");
        System.out.println("Circle Area: " + circle.getArea());
        Shape rectangle = shapeFactory.getShape("RECTANGLE");
        System.out.println("Rectangle Area: " + rectangle.getArea());
        Shape triangle = shapeFactory.getShape("TRIANGLE");
        System.out.println("Triangle Area: " + triangle.getArea());
    }
}
Problem–4 : Abstract Factory Pattern (Car Manufacturing)
public interface Car {
    void showSpecification();
}
public class UsaSmallCar implements Car {
    public void showSpecification() {
        System.out.println("USA Small Car: 1.0L, Red, Petrol");
    }
}
public class UsaSedanCar implements Car {
    public void showSpecification() {
        System.out.println("USA Sedan Car: 2.0L, Blue, Petrol");
    }
}
public class UsaLuxuryCar implements Car {
    public void showSpecification() {
        System.out.println("USA Luxury Car: 3.5L, Black, Petrol");
    }
}
public class AsiaSmallCar implements Car {
    public void showSpecification() {
        System.out.println("Asia Small Car: 0.8L, White, Electric");
    }
}
public class AsiaSedanCar implements Car {
    public void showSpecification() {
        System.out.println("Asia Sedan Car: 1.5L, Silver, Hybrid");
    }
}
public class AsiaLuxuryCar implements Car {
    public void showSpecification() {
        System.out.println("Asia Luxury Car: 2.5L, Champagne, Hybrid");
    }
}
public abstract class CarFactory {
    abstract Car createSmallCar();
    abstract Car createSedanCar();
    abstract Car createLuxuryCar();
}
public class UsaCarFactory extends CarFactory {

    public Car createSmallCar() {
        return new UsaSmallCar();
    }
    public Car createSedanCar() {
        return new UsaSedanCar();
    }
    public Car createLuxuryCar() {
        return new UsaLuxuryCar();
    }
}
public class AsiaCarFactory extends CarFactory {
    public Car createSmallCar() {
        return new AsiaSmallCar();
    }
    public Car createSedanCar() {
        return new AsiaSedanCar();
    }
    public Car createLuxuryCar() {
        return new AsiaLuxuryCar();
    }
}
public class FactoryProducer {
    public static CarFactory getFactory(String region) {
        if (region.equalsIgnoreCase("USA"))
            return new UsaCarFactory();
        else if (region.equalsIgnoreCase("ASIA"))
            return new AsiaCarFactory();

        return null;
    }
}
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        CarFactory usaFactory = FactoryProducer.getFactory("USA");
        usaFactory.createSmallCar().showSpecification ();
        usaFactory.createSedanCar().showSpecification ();
        usaFactory.createLuxuryCar().showSpecification ();

        System.out.println();

        CarFactory asiaFactory =  FactoryProducer.getFactory("ASIA");
        asiaFactory.createSmallCar().showSpecification ();
        asiaFactory.createSedanCar().showSpecification ();
        asiaFactory.createLuxuryCar().showSpecification ();
    }
}
output:
USA Small Car: 1.0L, Red, Petrol
USA Sedan Car: 2.0L, Blue, Petrol
USA Luxury Car: 3.5L, Black, Petrol

Asia Small Car: 0.8L, White, Electric
Asia Sedan Car: 1.5L, Silver, Hybrid
Asia Luxury Car: 2.5L, Champagne, Hybrid 
UML:
        Car
        +showSpecification()
           ▲
           |
 ----------------------------
 |          |               |
UsaSmall  AsiaSmall     UsaSedan ...
 
        CarFactory
  +createSmallCar()
  +createSedanCar()
  +createLuxuryCar()
           ▲
     ----------------
     |              |
UsaCarFactory   AsiaCarFactory

____________Abstract Factory Pattern__________________
//Car.java
public interface Car {
    void showSpecifications();
    
}
//AbstractCar.java
public abstract class AbstractCar implements Car{
    protected String engineVolume;
    protected String color;
    protected String fuelType;

    public void showSpecifications(){
        System.out.println("Engile: "+engineVolume);
        System.out.println("Color: "+color);
        System.out.println("Fuel: "+fuelType);
    }
}

//UsaSmallCar.java
public class UsaSmallCar extends AbstractCar{
    public UsaSmallCar(){
        engineVolume = "1.0L";
        color = "Red";
        fuelType = "Petrol";
    }
}

//UsaSedanCar.java
public class UsaSedanCar extends AbstractCar{
    public UsaSedanCar(){
        engineVolume = "2.0L";
        color = "Blue";
        fuelType = "Petrol";
    }
}
//UsaLuxuryCar.java
public class UsaLuxuryCar extends AbstractCar{
    public UsaLuxuryCar(){
        engineVolume = "3.5L";
        color = "Black";
        fuelType = "Petrol";
    }
}

//AsiaSmallCar.java
public class AsiaSmallCar extends AbstractCar{
    public AsiaSmallCar(){
        engineVolume = "0.8L";
        color = "White";
        fuelType = "Electric";
    }
}

//AsiaSedanCar.java
public class AsiaSedanCar extends AbstractCar{
    public AsiaSedanCar(){
        engineVolume = "1.5L";
        color = "Silver";
        fuelType = "Hybrid";
    }
}

//AsiaLuxuryCar.java
public class AsiaLuxuryCar extends AbstractCar{
    public AsiaLuxuryCar(){
        engineVolume = "2.5L";
        color = "Champagne";
        fuelType = "Hybrid";
    }
}

//CarFactory.java
public abstract class CarFactory {
    abstract Car getCar(String carType);
    
} 

//UsaCarFactory.java
public class UsaCarFactory extends CarFactory{
    public Car getCar(String carType){
        if(carType.equalsIgnoreCase("UsaSmallCar")){
            return new UsaSmallCar();
        }
        else if(carType.equalsIgnoreCase("UsaSedanCar")){
            return new UsaSedanCar();
        }
        else if(carType.equalsIgnoreCase("UsaLuxuryCar")){
            return new UsaLuxuryCar();
        }
        return null;
    }
    
}

//AsiaCarFactory.java
public class AsiaCarFactory extends CarFactory{
    public Car getCar(String carType){
        if(carType.equalsIgnoreCase("AsiaSmallCar")){
            return new AsiaSmallCar();
        }
        else if(carType.equalsIgnoreCase("AsiaSedanCar")){
            return new AsiaSedanCar();
        }
        else if(carType.equalsIgnoreCase("AsiaLuxuryCar")){
            return new AsiaLuxuryCar();
        }
        return null;
    }
}

//FactoryProducer.java
package CarManufacturing;

public class FactoryProducer {
    public static CarFactory getFactory(boolean region) {
        if(region){
            return new AsiaCarFactory();
        }
        else{
            return new UsaCarFactory();
        }
    }
}

//CarClient.java

public class CarClient {
    public static void main(String[] args) {

        CarFactory usaCarfactory = FactoryProducer.getFactory(false);
        Car car1 = usaCarfactory.getCar("UsaLuxuryCar");
        car1.showSpecifications();

        CarFactory asiaCarFactory = FactoryProducer.getFactory(true);
        Car car2 = asiaCarFactory.getCar("AsiaLuxuryCar");
        car2.showSpecifications();
    }
}



problem: 1

Write a program to create various shapes like (Circle, Triangle, Rectangle) and calculate the area of the shape. You should use Factory Pattern for shape creation so that all shapes can be created using a single factory object.

Each shape should have their defining properties (For example circle should have radius, triangle should have length of its three side etc.) and a method named getArea() to calculate the area of the shape.

When creating a particular shape, you should initialize the shapes property with any default values (ie. for circle, redius =1; for rectangle width =2 and height=1.5 etc.)

Problem: 2

Simulate a meal ordering system where different types of meals (e.g., vegetarian and non-vegetarian) are constructed using the Builder Design Pattern. A typical meal consists of a burger and a cold drink.

The burger can be either a Veg Burger or a Chicken Burger, and it is packed using a wrapper.

The cold drink can be either a Coke or a Pepsi, and it is packed in a bottle.

Use the Builder Pattern to encapsulate the logic for constructing these meals step-by-step.

Your program should:

Display both vegetarian and non-vegetarian meals with the list of items included.

Show the total cost of each meal.

Draw a UML class diagram representing the system's structure.



Problem:

Write a program that can create different geometric shapes Circle. Triangle, and Rectangle and calculate the area of each shape
Use the Factory Design Pattern to create the shapes. A single ShapeFactory class should be responsible for creating all types of shapes.

Requirements:

1. Define a conumon interface or abstract class Shape that declares a method getArea().
2. Each concrete shape class must:
Store its own defining properties
Circle: radius
Rectangle: width and height
Triangle: lengths of its three sides
Implement the getArea() method to return the correct area.

3. When a shape object is created by the factory, initialize it with default values, for example:
Circle: radius = 1
Rectangle: width = 2, height = 1.5
Triangle: side lengths = 3, 4, and 5
The main program should request shapes from the factory and display the calculated area for each shape.

Problem:

Suppose a customer wants to withdraw cash from a bank account using a cheque. The bank follows specific authorization rules based on the amount written on the cheque.
Implement the following business rules using the Chain of Responsibility Design Pattern and Also draw UML class diagram for the system.
Business Rules
For an amount less than Tk. 10,000, authorization from the Cashier alone is sufficient.
For an amount from Tk. 10,000 up to Tk. 1,000,000, the cheque must be authorized by both the Cashier and a Senior Officer.
For an amount greater than Tk. 1,000,000:
The Cashier does not authorize the withdrawal and only forwards the cheque to the Senior Officer.
The withdrawal must be authorized by both the Senior Officer and the Manager.

Problem: 1

You are a software engineer at Global Motors, which manufactures cars in two regions: USA and Asia. The company produces three types of cars: Small, Sedan, and Luxury. Each region has its own manufacturing process due to local requirements given in the table below.

Region Specific Car Features

Region 	 Car-Type 	 Engine Volume  	Color 		Fuel Type

USA		  Small		 1.0L		Red		Petrol

USA		Sedan			2.0L		Blue		Petrol

USA		Luxury		3.5L		Black		Petrol

Asia		Small			0.8L		White		Electric

Asia		Sedan			1.5L		Silver		Hybrid

Asia		Luxury		2.5L		Champagne  Hybrid

Implement the Abstract Factory design pattern to represent the car-making process for both USA and Asia.
Each region will have its own factory, which knows how to create each type of car (Small, Sedan, Luxury) using that region's specific logic.
The code should be flexible and extensible, so that new car types or new regions can be added in the future without major changes to existing code.
Draw UML class diagram for the system.

Problem: 2

Suppose we want to withdraw cash from our bank account using check. Bank has the following business rule for cash withdrawal based on the amount written on check.

a) For Tk. 10,000 only cashier's authorization is sufficient to withdraw money from account.

b) For Tk. 10,000 to 10,00,000 authorization from both cashier and senior officer is needed

c) For Tk > 10,00,000 authorization from Senior officer and Manager is mandatory.

Implement this business rule using Chain of Responsibility design pattern. Also draw UML class diagram for the system.



package com.tutorialspoint;

public class SingletonPatternDemo {
   public static void main(String[] args) {

      //illegal construct
      //Compile Time Error: The constructor SingleObject() is not visible
      //SingleObject object = new SingleObject();

      //Get the only object available
      SingleObject object = SingleObject.getInstance();

      //show the message
      object.showMessage();
   }
}

class SingleObject {

   //create an object of SingleObject
   private static SingleObject instance = new SingleObject();

   //make the constructor private so that this class cannot be
   //instantiated
   private SingleObject(){}

   //Get the only object available
   public static SingleObject getInstance(){
      return instance;
   }

   public void showMessage(){
      System.out.println("Hello World!");
   }
}
